package utils

import (
	"crypto/ecdsa"
	"io/ioutil"
	"sync"

	"github.com/ethereum/go-ethereum/accounts"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/accounts/keystore"
	"github.com/ethereum/go-ethereum/crypto"
)

// Authorizer wraps the bind.TransactOpts type making it safe for concurrent use.
// A number of fields within bind.TransactOpts are not concurrency safe, and as such you must leverage
// the embedded mutex type befopre using the transactor.
type Authorizer struct {
	sync.Mutex // bind.TransactOpts is not thread safe
	*bind.TransactOpts
}

// NewAuthorizer returns an Authorizer object using a keyfile as the account source
func NewAuthorizer(keyFile, keyPass string) (*Authorizer, error) {
	fileBytes, err := ioutil.ReadFile(keyFile)
	if err != nil {
		return nil, err
	}
	pk, err := keystore.DecryptKey(fileBytes, keyPass)
	if err != nil {
		return nil, err
	}
	return NewAuthorizerFromPK(pk.PrivateKey), nil
}

// NewAuthorizerFromPK returns an authorizer from a private key
func NewAuthorizerFromPK(pk *ecdsa.PrivateKey) *Authorizer {
	return &Authorizer{TransactOpts: bind.NewKeyedTransactor(pk)}
}

// NewKeyFile returns a new ethereum account as generated by `geth account new`
func NewKeyFile(keyFileDir, keyPass string) (accounts.Account, error) {
	return keystore.StoreKey(keyFileDir, keyPass, keystore.StandardScryptN, keystore.StandardScryptP)
}

// NewAccount creates a new ethereum private key, and associated transactor
func NewAccount() (*bind.TransactOpts, *ecdsa.PrivateKey, error) {
	key, err := crypto.GenerateKey()
	if err != nil {
		return nil, nil, err
	}
	return bind.NewKeyedTransactor(key), key, err
}
